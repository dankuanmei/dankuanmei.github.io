<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ダン・クァン・ミン Blog]]></title>
  <link href="http://dankuanmei.github.io/atom.xml" rel="self"/>
  <link href="http://dankuanmei.github.io/"/>
  <updated>2015-07-04T16:35:02+09:00</updated>
  <id>http://dankuanmei.github.io/</id>
  <author>
    <name><![CDATA[ダン・クァン・ミン]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Setup Cakephp 3.x]]></title>
    <link href="http://dankuanmei.github.io/blog/2015/07/04/setup-cakephp-3-dot-x/"/>
    <updated>2015-07-04T16:18:28+09:00</updated>
    <id>http://dankuanmei.github.io/blog/2015/07/04/setup-cakephp-3-dot-x</id>
    <content type="html"><![CDATA[<h2>Installing CakePHP</h2>

<p>First, you’ll need to download and install Composer if you haven’t done so already. If you have cURL installed, it’s as easy as running the following:</p>

<pre><code>curl -s https://getcomposer.org/installer | php
</code></pre>

<p>Now that you’ve downloaded and installed Composer, you can get a new CakePHP application by running:</p>

<pre><code>php composer.phar create-project --prefer-dist cakephp/app [app_name]
</code></pre>

<p>Or if Composer is installed globally:</p>

<pre><code>composer create-project --prefer-dist cakephp/app [app_name]
</code></pre>

<p>You can now visit the path to where you installed your CakePHP application and see the setup traffic lights.</p>

<h2>Development Server</h2>

<p>A development installation is the fastest method to setup CakePHP. In this example, we will be using CakePHP’s console to run PHP’s built-in web server which will make your application available at <a href="http://host:port.">http://host:port.</a> From the app directory, execute:</p>

<pre><code>bin/cake server -H 192.168.13.37 -p 5673
</code></pre>

<h2>Create <code>.htaccess</code> file</h2>

<p>CakePHP webroot directory (will be copied to your application’s web root by bake):</p>

<pre><code>&lt;IfModule mod_rewrite.c&gt;
    RewriteEngine on
    RewriteRule    ^$    app/webroot/    [L]
    RewriteRule    (.*) app/webroot/$1    [L]
&lt;/IfModule&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Apache2 Virtual Host on Ubuntu]]></title>
    <link href="http://dankuanmei.github.io/blog/2015/07/04/setup-apache2-virtual-host-on-ubuntu/"/>
    <updated>2015-07-04T13:20:58+09:00</updated>
    <id>http://dankuanmei.github.io/blog/2015/07/04/setup-apache2-virtual-host-on-ubuntu</id>
    <content type="html"><![CDATA[<h2>Create the Directory Structure</h2>

<p>The first step that we are going to take is to make a directory structure that will hold the site data that we will be serving to visitors.</p>

<pre><code>sudo mkdir -p /var/www/example.local/public_html
</code></pre>

<h2>Grant Permissions</h2>

<p>Now we have the directory structure for our files, but they are owned by our root user. If we want our regular user to be able to modify files in our web directories, we can change the ownership by doing this:</p>

<pre><code>sudo chown -R $USER:$USER /var/www/example.local/public_html
</code></pre>

<p>We should also modify our permissions a little bit to ensure that read access is permitted to the general web directory and all of the files and folders it contains so that pages can be served correctly:</p>

<pre><code>sudo chmod -R 755 /var/www
</code></pre>

<h2>Create Demo Pages for Each Virtual Host</h2>

<pre><code>vim /var/www/example.local/public_html/index.html
</code></pre>

<p>In this file, create a simple HTML document that indicates the site it is connected to. My file looks</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Welcome to example.local!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Success!  The example.local virtual host is working!&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2>Enable mod rewrite(Optional)</h2>

<pre><code>sudo a2enmod rewrite
sudo service apache2 restart
</code></pre>

<h2>Create New Virtual Host Files</h2>

<p>Create the First Virtual Host File</p>

<pre><code>sudo cp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/example.local.conf
</code></pre>

<p>Open and Edit the file.</p>

<pre><code>sudo vim /etc/apache2/sites-available/example.local.conf
</code></pre>

<p>Sample</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerAdmin admin@example.local
    ServerName example.local
    ServerAlias www.example.local
    DocumentRoot /var/www/example.local/public_html
    &lt;Directory /var/www/example.local/public_html&gt;
      AllowOverride all
    &lt;/Directory&gt;
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
&lt;/VirtualHost&gt;
</code></pre>

<p>Save and close the file.</p>

<h2>Enable the New Virtual Host Files</h2>

<p>We can use the a2ensite tool to enable each of our sites like this:</p>

<pre><code>sudo a2ensite example.local.conf
</code></pre>

<p>When you are finished, you need to restart Apache to make these changes take effect:</p>

<pre><code>sudo service apache2 restart
</code></pre>

<h2>Set Up Local Hosts File (Optional)</h2>

<p>If you haven&rsquo;t been using actual domain names that you own to test this procedure and have been using some example domains instead, you can at least test the functionality of this process by temporarily modifying the hosts file on your local computer.
If you are on a Mac or Linux computer, edit your local file with administrative privileges by typing:</p>

<pre><code>sudo vim /etc/hosts
</code></pre>

<p>For the domains that I used in this guide, assuming that my VPS IP address is 111.111.111.111, I could add the following lines to the bottom of my hosts file:</p>

<pre><code>127.0.0.1   localhost
127.0.1.1   guest-desktop
111.111.111.111 example.local
</code></pre>

<h2>Test your Results</h2>

<p>Now that you have your virtual hosts configured, you can test your setup easily by going to the domains that you configured in your web browser:
<a href="http://example.local">http://example.local</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Presentation Time Stamp]]></title>
    <link href="http://dankuanmei.github.io/blog/2015/07/03/the-presentation-time-stamp/"/>
    <updated>2015-07-03T11:03:43+09:00</updated>
    <id>http://dankuanmei.github.io/blog/2015/07/03/the-presentation-time-stamp</id>
    <content type="html"><![CDATA[<h2>wikipedia</h2>

<p>The presentation timestamp (PTS) is a timestamp metadata field in an MPEG transport stream or MPEG program stream that is used to achieve synchronization of programs' separate elementary streams (for example Video, Audio, Subtitles) when presented to the viewer. The PTS is given in units related to a program&rsquo;s overall clock reference, either Program Clock Reference (PCR) or System Clock Reference (SCR), which is also transmitted in the transport stream or program stream.</p>

<p>Presentation time stamps have a resolution of 90kHz, suitable for the presentation synchronization task. The PCR or SCR has a resolution of 27MHz which is suitable for synchronization of a decoder&rsquo;s overall clock with that of the usual remote encoder, including driving TV signals such as frame and line sync timing, colour sub carrier, etc.</p>

<p>Decoding of N elementary streams is synchronized by adjusting the decoding of streams to a common master time base rather than by adjusting the decoding of one stream to match that of another. The master time base may be one of the N decoders' clocks, the data source’s clock, or it may be some external clock.</p>

<p>A transport stream may contain multiple programs and each program may have its own time base. The time bases of different programs within a transport stream may be different. Because PTSs apply to the decoding of individual elementary streams, they reside in the PES packet layer of both the transport streams and program streams. End-to-end synchronization occurs when encoders save time stamps at capture time, when the time stamps propagate with associated coded data to decoders, and when decoders use those time stamps to schedule presentations.</p>

<p>Synchronization of a decoding system with a channel is achieved through the use of the SCR in the program stream and by its analog, the PCR, in the transport stream. The SCR and PCR are time stamps encoding the timing of the bit stream itself, and are derived from the same time base used for the audio and video PTS values from the same program. Since each program may have its own time base, there are separate PCR fields for each program in a transport stream containing multiple programs. In some cases it may be possible for programs to share PCR fields.</p>

<h2>Vietnamese</h2>

<p>Có hai loại nhãn thời gian là nhãn thời gian trình diễn PTS (presentation time stamp) và nhãn thời gian giải mã DTS (decode time stamp)</p>

<p>Nhãn thời gian trình diễn được dùng để xác định khi nào thì hình ảnh sẽ được thể hiện trên màn ảnh, còn nhãn thời gian giải mã xác định khi nào hình ảnh được giải mã.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello Oxygine Framework]]></title>
    <link href="http://dankuanmei.github.io/blog/2015/07/03/hello-oxygine-framework/"/>
    <updated>2015-07-03T11:01:46+09:00</updated>
    <id>http://dankuanmei.github.io/blog/2015/07/03/hello-oxygine-framework</id>
    <content type="html"><![CDATA[<h2>Intro</h2>

<h4>Free, Open Source and Cross-Platform</h4>

<p>Oxygine is completely free and open source (MIT license) 2D game engine, available on BitBucket. It is written in C++ and runs on MacOSX, iOS, Android, Windows and Linux.</p>

<h4>Pure C++</h4>

<p>Oxygine is written in C++. It provides easy to use API, which is designed with &ldquo;do more with less code&rdquo; philosophy. It uses a managed scenegraph system that takes care of rendering and updates, and provides ability to extend with custom rendering and updates.</p>

<h4>Build for Web</h4>

<p>You can build and run your C++ Oxygine application in web browsers. It won’t require any plugins, such as Flash or Unity, and runs as pure HTML5/JS application using WebGL for rendering.</p>

<h4>Embedded Profiling Tools</h4>

<p>You can analyze your application with embedded tools. Inspect in runtime scenegraph, loaded textures, FPS, performance and more.</p>

<h4>Text Rendering</h4>

<p>Accurate unicode text rendering using bitmap fonts created with BMFont tool. Supports different alignment modes and substring colorization.</p>

<h4>Compresed Textures and Atlasses</h4>

<p>Oxygine provides command-line tools to build texture atlases with ability to convert it into compressed formats like PVRTC, ETC and more. Atlases can be automatically resized to any game resolution for higher quality.</p>

<h4>High Performance</h4>

<p>Oxygine is developed to be fast and memory efficient on mobile platforms. It has flexible resources management system, automatic sprites batching, memory pools and more.</p>

<h4>Build on top of the SDL2 and Marmalade</h4>

<p>You can build Oxygine on top of the SDL2, Marmalade, Emscripten or adapt to your platform.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sample About Sort]]></title>
    <link href="http://dankuanmei.github.io/blog/2015/07/02/sample-about-sort/"/>
    <updated>2015-07-02T19:57:25+09:00</updated>
    <id>http://dankuanmei.github.io/blog/2015/07/02/sample-about-sort</id>
    <content type="html"><![CDATA[<h2>Binary Sort</h2>

<pre><code>void BinSort(int x[ ], int n)
{
    int i, j;

    if (n &gt; MAX_DATA) {
        printf("データが多すぎます!\n");
        return;
    }
    else {
        for (i = 0; i &lt; MAX_DATA; i++)
            Bin[i] = 0;             /* 作業用配列の初期化 */

        for (i = 0; i &lt; n; i++)     /* x[i] の値の */
            Bin[x[i]]++;            /* Bin[ ] の要素の値を */
                                    /* インクリメント */
        j = 0;                      /* x[ ] の添字として使用 */
        for (i = 0; i &lt; MAX_DATA ; i++)
            if (Bin[i])             /* ０でなければ */
            x[j++] = i;             /* 書き戻す */
    }
}
</code></pre>

<h2>Buble Sort</h2>

<pre><code>int BubSort(int x[ ], int n)
{
    int i, j, temp;

    for (i = 0; i &lt; n - 1; i++) {
        for (j = n - 1; j &gt; i; j--) {
            if (x[j - 1] &gt; x[j]) {  /* 前の要素の方が大きかったら */
                temp = x[j];        /* 交換する */
                x[j] = x[j - 1];
                x[j - 1]= temp;
            }
        }
        /* ソートの途中経過を表示 */
        ShowData(x, NUM_DATA);
    }
}
</code></pre>

<h2>Heap Sort</h2>

<pre><code>void Hpsort(int a[ ], int n)
{
    int leaf, root;

    leaf = n;                   /* 初期値は末尾の要素 */
    root = n/2;                 /* 初期値はその親 */

    while (root &gt; 0 ) {         /* 半順序木を構成 */
        DownHeap(a, leaf, root);
        root--;
    }

    while(leaf &gt; 0) {
        Swap(a, 1, leaf);       /* 半順序木の根と末尾の要素を交換 */
        leaf--;                 /* 末尾の要素を半順序木から外す */
        DownHeap(a, leaf, 1);   /* 半順序木を再構成する */
    }
}

void DownHeap(int a[ ],  int leaf, int root)
{
    int i;

    i = root * 2;
    while (i &lt;= leaf) {
        if (i &lt; leaf &amp;&amp; a[i + 1] &gt; a[i])  /* a[i] と a[i + 1]  の大きい方と */
            i++;
        if (a[root] &gt;= a[i])              /* a[root] と比較 */
            break;                        /* 子の方が大きければ */
        Swap(a, root, i);                 /* 交換 */

        root = i;                         /* 更にその子についても調べる */
        i = root * 2;
    }
}

void Swap(int a[ ], int i, int j)
{
    int temp;

    temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}
</code></pre>

<h2>Quick Sort</h2>

<pre><code>void QSort(int x[ ], int left, int right)
{
    int i, j;
    int pivot;

    i = left;                      /* ソートする配列の一番小さい要素の添字 */
    j = right;                     /* ソートする配列の一番大きい要素の添字 */

    pivot = x[(left + right) / 2]; /* 基準値を配列の中央付近にとる */

    while (1) {                    /* 無限ループ */

        while (x[i] &lt; pivot)       /* pivot より大きい値が */
            i++;                   /* 出るまで i を増加させる */

        while (pivot &lt; x[j])       /* pivot より小さい値が */
            j--;                   /*  出るまで j を減少させる */
        if (i &gt;= j)                /* i &gt;= j なら */
            break;                 /* 無限ループから抜ける */

        Swap(x, i, j);             /* x[i] と x[j]を交換 */
        i++;                       /* 次のデータ */
        j--;
    }

    if (left &lt; i - 1)              /* 基準値の左に 2 以上要素があれば */
        QSort(x, left, i - 1);     /* 左の配列を Q ソートする */
    if (j + 1 &lt;  right)            /* 基準値の右に 2 以上要素があれば */
        QSort(x, j + 1, right);    /* 右の配列を Q ソートする */
}

void Swap(int x[ ], int i, int j)
{
    int temp;

    temp = x[i];
    x[i] = x[j];
    x[j] = temp;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://dankuanmei.github.io/blog/2015/07/02/hello-world/"/>
    <updated>2015-07-02T19:13:45+09:00</updated>
    <id>http://dankuanmei.github.io/blog/2015/07/02/hello-world</id>
    <content type="html"><![CDATA[<h3>Tự giới thiệu</h3>

<p>Cũng không có gì đặc biệt.</p>

<h3>酒と泪と男と女</h3>

<pre><code>忘れてしまいたい事や
どうしようもない 寂しさに
包まれた時に男は
酒を飲むのでしょう
飲んで飲んで 飲まれて飲んで
飲んで飲みつぶれて 寝むるまで飲んで
やがて男は 静かに寝むるのでしょう

忘れてしまいたい事や
どうしようもない 悲しさに
包まれた時に女は
泪みせるのでしょう
泣いて泣いて 一人泣いて
泣いて泣きつかれて 寝むるまで泣いて
やがて女は 静かに寝むるのでしょう

またひとつ 女の方が偉く思えてきた
またひとつ 男のずるさが見えてきた
俺は男 泣きとおすなんて出来ないよ

今夜も酒をあおって 眠ってしまうのさ
俺は男 泪はみせられないもの
飲んで飲んで 飲まれて飲んで
飲んで飲みつぶれて 眠るまで飲んで
やがて男は静かに 眠るのでしょう
</code></pre>
]]></content>
  </entry>
  
</feed>
