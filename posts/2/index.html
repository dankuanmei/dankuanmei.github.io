
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>ダン・クァン・ミン Blog</title>
  <meta name="author" content="ダン・クァン・ミン">

  
  <meta name="description" content="SNS avatar generator uiFaces http://uifaces.com/ Dùng trong trường hợp muốn tạo ra một loạt avatar dùng cho demo vân vân. Có tích hợp cả API, rất &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://dankuanmei.github.io/posts/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="ダン・クァン・ミン Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='//fonts.googleapis.com/css?family=Roboto+Condensed&subset=latin,vietnamese' rel='stylesheet' type='text/css'>
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">ダン・クァン・ミン Blog</a></h1>
  
    <h2>はじめまして</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
  
  
  
  
  
  
  
  
    
      <form action="https://www.google.com/search" method="get">
        <fieldset role="search">
          <input type="hidden" name="sitesearch" value="dankuanmei.github.io" />
    
          <input class="search" type="text" name="q" results="0" placeholder="Search"/>
        </fieldset>
      </form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/15/free-resource/">Free Resource</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-15T21:21:47+09:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:21 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><h3>SNS avatar generator</h3>

<p><code>uiFaces</code></p>

<p><a href="http://uifaces.com/">http://uifaces.com/</a></p>

<p>Dùng trong trường hợp muốn tạo ra một loạt avatar dùng cho demo vân vân.</p>

<p>Có tích hợp cả API, rất đáng để dùng thử.</p>

<h3>Free Video</h3>

<p><code>mazwai</code></p>

<p><a href="http://mazwai.com/#index">http://mazwai.com/#index</a></p>

<p>Toàn là video nhìn rất cool.</p>

<p><code>jQuery video background plugin</code></p>

<p><a href="https://github.com/VodkaBears/Vide">https://github.com/VodkaBears/Vide</a></p>

<h3>Icon</h3>

<p><code>iconfinder</code></p>

<p><a href="https://www.iconfinder.com/">https://www.iconfinder.com/</a></p>

<h3>Html template</h3>

<p><code>html5up</code></p>

<p><a href="http://html5up.net/">http://html5up.net/</a></p>

<p><code>startbootstrap</code></p>

<p><a href="http://startbootstrap.com/">http://startbootstrap.com/</a></p>

<p><code>blacktie</code></p>

<p><a href="http://www.blacktie.co/">http://www.blacktie.co/</a></p>

<h3>Free logo</h3>

<p><code>Squarespace</code> (Recommend)</p>

<p><a href="http://www.squarespace.com/logo#">http://www.squarespace.com/logo#</a></p>

<p><code>LOGASTER</code></p>

<p><a href="https://www.logaster.com/">https://www.logaster.com/</a></p>

<h3>CSS animation</h3>

<p><code>Animate.css</code> (Recommend)</p>

<p><a href="http://daneden.github.io/animate.css/">http://daneden.github.io/animate.css/</a></p>

<h3>HTML Gen</h3>

<p><code>coveloping</code> (Recommend)</p>

<p><a href="http://coveloping.com/">http://coveloping.com/</a></p>

<p>Tập hợp rất nhiều công cụ dùng để sinh ra các phần trong trang HTML như price page vân vân.</p>

<p><code>TeamPage.io</code></p>

<p><a href="http://www.teampage.io/">http://www.teampage.io/</a></p>

<p>Tạo team member page một cách rất đơn giản.</p>

<p><code>FRAME</code></p>

<p><a href="http://frame.lab25.co.uk/">http://frame.lab25.co.uk/</a></p>

<p>Sinh ra 1 top page na ná như trang đó.</p>

<p><code>UICloud</code></p>

<p><a href="http://ui-cloud.com/">http://ui-cloud.com/</a></p>

<p>Trang chuyên dùng cho việc search tham khảo những thành phần của UI.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/15/install-opengl-in-ubuntu/">Install openGL in Ubuntu</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-15T01:22:58+09:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:22 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Install command line</h3>

<pre><code>$ sudo apt-get install freeglut3-dev libglew1.5-dev

$ sudo apt-get install libxmu-dev libxi-dev

$ sudo apt-get install binutils-gold
</code></pre>

<h3>Complie command line</h3>

<pre><code>$ cc -I/usr/X11R6/include program.c -L/usr/X11R6/lib -lglut -lGLU -lGL -lXmu -lXi -lXext -lX11 -lm -lpthread

$ function ccgl() { cc -I/usr/X11R6/include "$@" -L/usr/X11R6/lib -lglut -lGLU -lGL -lXmu -lXi -lXext -lX11 -lm -lpthread; }

$ ccgl program.c
</code></pre>

<h2>#</h2>

<table>
<thead>
<tr>
<th> C                           </th>
<th> OpenGL                      </th>
</tr>
</thead>
<tbody>
<tr>
<td> signed char                 </td>
<td> GLbyte                      </td>
</tr>
<tr>
<td> unsigned char               </td>
<td> GLubyte, GLboolean          </td>
</tr>
<tr>
<td> short                       </td>
<td> GLshort                     </td>
</tr>
<tr>
<td> unsigned short              </td>
<td> GLushort                    </td>
</tr>
<tr>
<td> int, long                   </td>
<td> GLint, GLsizei              </td>
</tr>
<tr>
<td> unsigned int, unsigned long </td>
<td> GLuint, GLenum, GLbitfield  </td>
</tr>
<tr>
<td> float                       </td>
<td> GLfloat, GLclampf           </td>
</tr>
<tr>
<td> double                      </td>
<td> GLdouble, GLclampd          </td>
</tr>
</tbody>
</table>


<h3>Function</h3>

<p>void glutInit(int *argcp, char **argv);</p>

<p>glutInitWindowPosition();</p>

<p>glutInitWindowSize();</p>

<p>glutInitDisplayMode();</p>

<ul>
<li>GLUT_RGBA RGBA モード</li>
<li>GLUT_RGBAも GLUT_INDEX も記述されないときのデフォルト</li>
<li>GLUT_RGB  GLUT_RGBA と同じ</li>
<li>GLUT_INDEX    カラーインデックス モード</li>
<li>GLUT_RGBAも記述された場合，上書きする</li>
<li>GLUT_SINGLE   シングルバッファ モード</li>
<li>GLUT_DOUBLE もGLUT_SINGLEも記述されていない場合の デフォルトである</li>
<li>GLUT_DOUBLE   ダブルバッファ モード</li>
<li>GLUT_SINGLE も記述されていた場合，上書きする</li>
<li>GLUT_ACCUM    アキュムレーション バッファ</li>
<li>GLUT_ALPHA    カラーバッファにアルファ成分を加えること</li>
<li>GLUT_DEPTH    デプス(Z)バッファを加えること</li>
<li>GLUT_STENCIL  ステンシル・バッファを加えること</li>
<li>GLUT_MULTISAMPLE  マルチサンプリングのサポート</li>
<li>GLX_SAMPLE_SGIS エクステンションをサポートしていなければならない</li>
<li>GLUT_STEREO   ステレオ・ウィンドウビットマスク</li>
</ul>


<p>int glutCreateWindow(char *name);</p>

<p>void glutDisplayFunc(void (*func)(void));</p>

<p>void glClear(GLbitfield mask);</p>

<p>void glClearColor(GLclampf red,  GLclampf green,  GLclampf blue,  GLclampf alpha);</p>

<p>void glBegin(GLenum  mode);</p>

<p>void glEnd(void);</p>

<p>void glFlush();</p>

<h3>Sample</h3>

<pre><code>#include &lt;windows.h&gt;
#include &lt;GL/gl.h&gt;
#include &lt;GL/glut.h&gt;

void disp(void) {
    glClearColor(1 , 1 , 1 , 0);
    glClear(GL_COLOR_BUFFER_BIT);

    glBegin(GL_POLYGON);
    glEnd();

    glFlush();
}

int main(int argc , char ** argv) {
    glutInit(&amp;argc , argv);
    glutInitWindowPosition(100 , 50);
    glutInitWindowSize(200 , 100);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);

    glutCreateWindow("Kitty on your lap");
    glutDisplayFunc(disp);
    glutMainLoop();
    return 0;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/11/install-golang/">Install GoLang</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-11T13:46:29+09:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:46 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/11/java-design-patterns-factory-methods/">Java Design Patterns - Factory Methods</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-11T11:38:55+09:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:38 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><p>Định nghĩa một interface cho việc tạo ra một đối tượng, nhưng để cho các lớp con quyết định lớp nào sẽ tạo đối tượng. Factory Method cho phép một lớp hoãn việc tạo đối tượng sang các lớp con.</p>

<p><img src="http://i.imgur.com/KCE7HIw.png"></p>

<h2>#</h2>

<p>Interface sản phẩm</p>

<pre><code>public interface Weapon {

}
</code></pre>

<h2>#</h2>

<p>Interface factory chứa method để tạo sản phẩm</p>

<pre><code>public interface Blacksmith {

    Weapon manufactureWeapon(WeaponType weaponType);

}
</code></pre>

<h2>#</h2>

<p>Các subclass factory thực thi để tạo sản phẩm</p>

<pre><code>public class ElfBlacksmith implements Blacksmith {

    public Weapon manufactureWeapon(WeaponType weaponType) {
        return new ElfWeapon(weaponType);
    }

}

public class OrcBlacksmith implements Blacksmith {

    public Weapon manufactureWeapon(WeaponType weaponType) {
        return new OrcWeapon(weaponType);
    }

}
</code></pre>

<h2>#</h2>

<p>Các subclass sản phẩm</p>

<pre><code>public class ElfWeapon implements Weapon {

    private WeaponType weaponType;

    public ElfWeapon(WeaponType weaponType) {
        this.weaponType = weaponType;
    }

    @Override
    public String toString() {
        return "Elven " + weaponType;
    }

}

public class OrcWeapon implements Weapon {

    private WeaponType weaponType;

    public OrcWeapon(WeaponType weaponType) {
        this.weaponType = weaponType;
    }

    @Override
    public String toString() {
        return "Orcish " + weaponType;
    }

}
</code></pre>

<h2>#</h2>

<p>Class chứa loại sản phẩm</p>

<pre><code>public enum WeaponType {

    SHORT_SWORD("short sword"), SPEAR("spear"), AXE("axe"), UNDEFINED("");

    private String title;

    WeaponType(String title) {
        this.title = title;
    }

    @Override
    public String toString() {
        return title;
    }
}
</code></pre>

<h3>Application</h3>

<p>Class chạy thực thi, khởi tạo đối tượng sản phẩm và đối tượng factory. Tạo factory tương ứng với sản phẩm muốn tạo và truyền vào loại sản phẩm.</p>

<pre><code>/**
 * 
 * In Factory Method we have an interface (Blacksmith) with a method for
 * creating objects (manufactureWeapon). The concrete subclasses (OrcBlacksmith,
 * ElfBlacksmith) then override the method to produce objects of their liking.
 * 
 */
public class App {

    public static void main(String[] args) {
        Blacksmith blacksmith;
        Weapon weapon;

        blacksmith = new f();
        weapon = blacksmith.manufactureWeapon(WeaponType.SPEAR);
        System.out.println(weapon);
        weapon = blacksmith.manufactureWeapon(WeaponType.AXE);
        System.out.println(weapon);

        blacksmith = new ElfBlacksmith();
        weapon = blacksmith.manufactureWeapon(WeaponType.SHORT_SWORD);
        System.out.println(weapon);
        weapon = blacksmith.manufactureWeapon(WeaponType.SPEAR);
        System.out.println(weapon);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/10/abstract-factory-va-factory-pattern/">Abstract Factory và Factory Method</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-10T21:08:50+09:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:08 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><p><code>Interviewer</code> Chà chà, chào hai anh, đây là lần đầu tiên blog của iem phỏng vấn hai anh, hai anh cảm thấy thế nào.</p>

<p><code>Factory Method</code> Tôi ko biết sao hay bị gộp chúng với cha <code>Abstract Factory</code>. Đều là factory pattern không có nghĩa chúng tôi không được có những buổi phỏng vấn riêng.</p>

<p><code>Interviewer</code> Ấy ấy, đừng tự ái, em muốn phỏng vấn cả hai anh cùng nhau để giúp đọc giả phân biệt được ai là ai. Hai anh có nhiều điểm giống nhau, và em có nghe vài phàn nàn rằng người ta thỉnh thoảng bị rối và không thể phân biệt được 2 người.</p>

<p><code>Abstract Factory</code> Ừ đúng đấy, đã có lúc tôi bị nhầm lẫn là cha <code>Factory Method</code>, và tôi biết ổng cũng bị giống như tôi. Hai tụi tôi đều giỏi trong việc giảm sự phụ thuộc giữa chương trình với những cài đặt cụ thể; nhưng mỗi người chúng tôi lại có những cách làm riêng nên thỉnh thoảng dân lập trình lại cảm thấy rối và không thể xác định được phải dùng cách nào.</p>

<p><code>Factory Method</code> Ấy, người ta vẫn phân biệt được tôi mà. Nói chung, tôi dùng các lớp để tạo ra products, còn cha dùng những đối tượng; hai cách đó hoàn toàn khác nhau nhé.</p>

<p><code>Interviewer</code> Ừ em có tìm hiểu về hai anh rồi mà vẫn còn rối đây này, anh có thể nói thêm về khoản này không, anh <code>Factory Method</code>?</p>

<p><code>Factory Method</code> Ok, Cả cha <code>Abstract Factory</code> và tôi đều tạo ra các products, các objects, đó là việc chúng tôi phải làm. Nhưng tôi làm nhờ vào sự kế thừa (inheritance) …</p>

<p><code>Abstract Factory</code> … còn tôi làm nhờ vào sự kết hợp các đối tượng.</p>

<p><code>Factory Method</code> Đúng thía, nghĩa là nếu muốn tạo ra các đối tượng bằng cách <code>Factory Method</code>, người ta cần phải extend một lớp và override lại hàm tạo <code>Factory Method</code>.</p>

<p><code>Interviewer</code> …rồi <code>Factory Method</code> sẽ làm cái gì?</p>

<p><code>Factory Method</code> Tất nhiên là tạo ra 1 object roài, anh đã từng viết bài về tôi mà giờ còn hỏi hả. Ý tưởng của tôi, <code>Factory Method</code> Pattern, là sẽ sử dụng các lớp con để sinh ra 1 đối tượng mong muốn. Bằng cách đó, người dùng sẽ chỉ cần biết đến lớp trừu tượng như gia cầm, và các lớp con cụ thể sẽ lo về các kiểu gà, kiểu vịt, kiểu ngan. Vì vậy, nói theo cách khác, tôi giúp chương trình độc lập với các kiểu (type) cụ thể đó.</p>

<p><code>Abstract Factory</code> Ý tưởng của tôi cũng giống giống vậy đó, nhưng chỉ là làm theo một cách khác…</p>

<p><code>Interviewer</code> Tiếp đi anh <code>Abstract Factory</code> … vừa rồi anh có đề cập đến cách kết hợp các đối tượng?</p>

<p><code>Abstract Factory</code> Ờ,cách của tôi thế này: Tôi tạo ra một kiểu trừu tượng (abstract type) để dùng vào việc tạo ra một nhóm những products khác. Khi đó, những lớp con của kiểu trừu tượng sẽ xác định cách tạo ra các products này. Để áp dụng được ý tưởng của tôi, bạn phải tạo ra một instance của một trong các lớp con trên (instance này là 1 factory) và đưa nó vào chỗ cần thiết trong code. Vì thế, giống như <code>Factory Method</code>, những nơi sử dụng factory của tôi sẽ hoàn toàn độc lập với những produtcts cụ thể.</p>

<p><code>Interviewer</code> Oh yè, tôi biết rồi, một lợi ích nữa của cách này là anh đã nhóm các products tương tự nhau lại, có đúng không?</p>

<p><code>Abstract Factory</code> Đúng roài cưng à.</p>

<p><code>Interviewer</code> Bây giờ người ta cần bổ sung thêm một product nữa vô nhóm các products mà anh có thể tạo ra. Vậy không cần phải thay đổi gì hết huh?</p>

<p><code>Abstract Factory</code> Hèm, trường hợp này thì tôi phải thay đổi chút ít, nhiều người không thích lắm ở điểm này.</p>

<p><code>Factory Method</code> hĩ hĩ</p>

<p><code>Abstract Factory</code> Cười gì cha nội?</p>

<p><code>Factory Method</code> Cười chứ sao ko cười, làm vậy quá mất công chứ gì nữa. Cha thay đổi có nghĩa là người dùng phải đi mà đổi tất cả các lớp con roài? (các lớp con ở đây là các factories)</p>

<p><code>Abstract Factory</code> Đúng, nhưng cần phải làm như vậy vì tôi có khả năng tạo ra nhiều kiểu product khác nhau, trong khi người ta xài cách của anh khi họ cần tạo ra một kiểu product nào đó thôi, vì thế anh không có cồng kềnh như tôi, anh chỉ cần một method duy nhất.</p>

<p><code>Interviewer</code> Anh <code>Abstract Factory</code> bớt nóng, tôi nghe đồn rằng anh thường sử dụng nhiều hàm <code>Factory Method</code> theo cách của anh <code>Factory Method</code> để tạo các đổi tượng bên trong những factories của anh, điều đó có đúng ko?</p>

<p><code>Abstract Factory</code> Đúng đó em, anh thừa nhận điêu này. Những lớp factory con thường dùng các <code>Factory Method</code> để tạo các products tương ứng. Trong trường hợp này, các <code>Factory Method</code> được dùng thuần túy để tạo ra các products.</p>

<p><code>Factory Method</code> … còn tôi dùng hàm <code>Factory Method</code> để tạo ra product cụ thể mà người ta muốn, người dùng sẽ không biết cái gì được tạo ra, họ chỉ cần gọi hàm.</p>

<p><code>Interviewer</code> Dường như hai anh làm rất tốt công việc của mình. Tôi chắc rằng đọc giả đã có được lựa chọn của mình. Sau cùng, những factories của 2 anh quả thật rất hữu ích, đọc giả của tôi sẽ sử dụng chúng trong các tình huống thích hợp nhất. Các anh đều đóng gói (encapsulate) quá trình tạo ra đối tượng để giúp chương trình độc lập và giảm phụ thuộc với những kiểu cụ thể, việc làm này thật đáng tuyên dương. Cám ơn hai anh, hai anh có lời gì trước khi chào tạm biệt đọc giả không ạ?</p>

<p><code>Abstract Factory</code> Cám ơn. Hãy nhớ đến tôi, <code>Abstract Factory</code>, và sử dụng tôi bất cứ khi nào bạn cần cùng một lúc tạo ra nhiều loại products, và khi bạn muốn chắc chắn những nơi sử dụng sẽ không cần biết đến những lớp cụ thể khi cần làm việc này.</p>

<p><code>Factory Method</code> Còn tôi là <code>Factory Method</code>, hãy sử dụng tôi để làm cho chương trình của bạn độc lập với những lớp cụ thể mà bạn cần tạo 1 đối tượng, hoặc khi bạn không biết sau này sẽ cần đến những lớp con nào nữa. Khi cần sử dụng tôi, hãy tạo tạo ra subclass (1 factory implement 1 kiểu abstract) và implement <code>Factory Method</code> cho chính bạn.</p>

<p>(Page 158-162 of Head First – Design Pattern)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/10/java-design-patterns-abstract-factory/">Java Design Patterns - Abstract Factory</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-10T20:08:31+09:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>8:08 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><p>The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes.In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interface of the factory to create the concrete objects that are part of the theme. The client doesn&rsquo;t know (or care) which concrete objects it gets from each of these internal factories, since it uses only the generic interfaces of their products.This pattern separates the details of implementation of a set of objects from their general usage and relies on object composition, as object creation is implemented in methods exposed in the factory interface.</p>

<p>An example of this would be an abstract factory class DocumentCreator that provides interfaces to create a number of products (e.g. createLetter() and createResume()). The system would have any number of derived concrete versions of the DocumentCreator class like FancyDocumentCreator or ModernDocumentCreator, each with a different implementation of createLetter() and createResume() that would create a corresponding object like FancyLetter or ModernResume. Each of these products is derived from a simple abstract class like Letter or Resume of which the client is aware. The client code would get an appropriate instance of the DocumentCreator and call its factory methods. Each of the resulting objects would be created from the same DocumentCreator implementation and would share a common theme (they would all be fancy or modern objects). The client would only need to know how to handle the abstract Letter or Resume class, not the specific version that it got from the concrete factory.</p>

<p>A factory is the location of a concrete class in the code at which objects are constructed. The intent in employing the pattern is to insulate the creation of objects from their usage and to create families of related objects without having to depend on their concrete classes.This allows for new derived types to be introduced with no change to the code that uses the base class.</p>

<p>Use of this pattern makes it possible to interchange concrete implementations without changing the code that uses them, even at runtime. However, employment of this pattern, as with similar design patterns, may result in unnecessary complexity and extra work in the initial writing of code. Additionally, higher levels of separation and abstraction can result in systems which are more difficult to debug and maintain.</p>

<p><img src="http://i.imgur.com/pmd3pvQ.png"></p>

<p>Factory design pattern phải đảm bảo được những yếu tố sau:</p>

<ul>
<li>Việc khởi tạo những object phải được che giấu ở phía client.</li>
<li>Việc sử dụng những object mới được tạo ra phải thông qua một common interface.</li>
</ul>


<p>Việc triển khai này thực sự rất đơn giản, nó bao gồm những bước sau:</p>

<ul>
<li>Client cần một product, nhưng thay vì khởi tạo product object trực tiếp thông qua từ khóa new, nó sẽ hỏi factory object cho việc khởi tạo một object mới của product, cung cấp thông tin về loại dữ liệu của object cần thiết.</li>
<li>Phía factory sẽ khởi tạo một object cụ thể và trả về cho client một object product mới được tạo(đã được ép kiểu thành loại abstract product class)</li>
<li>Client sử dụng những object product này như là abstract product mà không quan tâm đến việc chúng được khởi tạo như thế nào.</li>
</ul>


<p>Ví dụ về một ứng dụng có chức năng tạo giao diện GUI. Ứng dụng của bạn sẽ có một client, GUIs là những product. Tất cả những GUI này đều có nguồn gốc từ một abstract class(hoặc một interface). GUI class này định nghĩa ra Button hay Label theo mỗi loại máy tính cụ thể. Giả sử có lệnh từ client là tạo Button và Label cho máy Windows, trong source code bạn phải nhận diện được kiểu máy tính như là một tham số, sau đó sẽ gọi đến Factory để thực hiện tạo ra giao diện tương ứng, ở đây là cho máy Windows. Như vậy, phía client hoàn toàn không cần quan tâm đến việc thực hiện tạo ra giao diện là như thế nào. Đó chính là mục đích của Factory Design Pattern.</p>

<p>Lợi ích ở đây chính là việc một hay nhiều loại máy tính mới có thể được thêm vào mà không cần phải sửa lại source code của ứng dụng quá nhiều. Việc thay đổi source code hoàn toàn không ảnh hưởng đến factory class.</p>

<h3>Java Example</h3>

<p>GuiFactory example</p>

<h4>Abstract Product</h4>

<pre><code>interface Button {
    void paint();
}

interface Label {
    void paint();
}
</code></pre>

<h4>Abstract Factory</h4>

<pre><code>interface GUIFactory {
    Button createButton();
    Label createLabel();
}
</code></pre>

<h4>Concrete Factory</h4>

<pre><code>class WinFactory implements GUIFactory {
    public Button createButton() {
        return new WinButton();
    }

    public Label createLabel() {
        return new WinLabel();
    }
}

class OSXFactory implements GUIFactory {
    public Button createButton() {
        return new OSXButton();
    }

    public Label createLabel() {
        return new OSXLabel();
    }

}
</code></pre>

<h4>Concrete Product</h4>

<pre><code>class OSXButton implements Button {
    public void paint() {
        System.out.println("I'm an OSXButton");
    }
}

class WinButton implements Button {
    public void paint() {
        System.out.println("I'm a WinButton");
    }
}

class OSXLabel implements Label {
    public void paint() {
        System.out.println("I'm an OSXLabel");
    }
}

class WinLabel implements Label {
    public void paint() {
        System.out.println("I'm a WinLabel");
    }
}
</code></pre>

<h4>Client</h4>

<p>Client application không quan tâm làm thế nào mà sản phẩm được tạo ra. Nó chỉ chịu trách nhiệm nhận về tên của Concrete Factory</p>

<pre><code>class Application {
    public Application(GUIFactory factory) {
        Button button = factory.createButton();
        Label label = factory.createLabel();
        button.paint();
        label.paint();
    }
}

public class ApplicationRunner {
    public static void main(String[] args) {
        new Application(createOsSpecificFactory());
    }

    public static GUIFactory createOsSpecificFactory() {
        String osname = System.getProperty("os.name").toLowerCase();
        if(osname != null &amp;&amp; osname.contains("windows"))
            return new WinFactory();
        else
            return new OSXFactory();
    }
}
</code></pre>

<h3>Java Example 2</h3>

<h4>Client</h4>

<pre><code>public class App {

    public static void main(String[] args) {
        createKingdom(new ElfKingdomFactory());
        createKingdom(new OrcKingdomFactory());
    }

    public static void createKingdom(KingdomFactory factory) {
        King king = factory.createKing();
        Castle castle = factory.createCastle();
        Army army = factory.createArmy();
        System.out.println("The kingdom was created.");
        System.out.println(king);
        System.out.println(castle);
        System.out.println(army);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/10/mot-so-quan-he-giua-cac-class-trong-uml/">Một Số Quan Hệ Giữa Các Class Trong UML</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-10T10:53:15+09:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:53 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><p>Quan hệ giữa các class trong UML, gồm có các 4 quan hệ chính sau:</p>

<ol>
<li>Realization</li>
<li>Generation</li>
<li>Dependency</li>
<li>Association: có 2 quan hệ phân biệt Aggregation &amp; Composition</li>
</ol>


<h3>Quan hệ Realization (hiện thực hóa)</h3>

<p>Là quan hệ giữa một classifier đóng vai trò là hợp đồng và một classifier đóng vai trò thực hiện. Hay nói cách khác:</p>

<p>Mối quan hệ giữa 1 class implement 1 interface được gọi là quan hệ realization, được biểu diễn bởi đường đứt nét có hình mũi tên tam giác chỉ vào interface.</p>

<p><img src="http://i.imgur.com/24Do9yQ.png"></p>

<h3>Quan hệ generalization (tên khác là Inheritance)</h3>

<p>Còn có tên khác là:</p>

<ul>
<li>Quan hệ tổng quát hóa</li>
<li>Quan hệ khái quát hóa</li>
<li>Quan hệ kế thừa</li>
</ul>


<p>Đối tượng cụ thể (concrete) sẽ kế thừa các thuộc tính và phương thức của đối tượng tổng quát (general)</p>

<p>Ký hiệu: A is-a B</p>

<p><img src="http://i.imgur.com/jYOTHlb.png"></p>

<p>Đọc là :</p>

<ul>
<li>A là tổng quát của B, B là chi tiết của A</li>
<li>B là trường hợp đặc biệt của A</li>
<li>A là cha của B, B là con của A</li>
</ul>


<h3>Quan hệ Dependency (phụ thuộc)</h3>

<p>Là quan hệ giữa 2 phần tử trong mô hình mà thay đổi ở phần tử này (phần tử độc lập) có thể gây ra thay đổi ở phần tử kia (phần tử phục thuộc).</p>

<p>Là loại quan hệ giữa 2 object</p>

<p>ClassA và ClassB không có quan hệ Association</p>

<p>Trong ClassA có sử dụng biến toàn cục (kiểu B), hoặc sử dụng phương thức/thuộc tính static của ClassB</p>

<p>Ký hiệu : A use-a B ,  bằng mũi tên 1 chiều nét đứt , từ bên phụ thuộc sang bên độc lập ;</p>

<p><img src="http://i.imgur.com/vj6U2En.png"></p>

<p>ClassA “phụ thuộc” vào ClassB ;</p>

<p>Client –> Supplier (phần tử phục thuộc –> phần tử độc lập)</p>

<p>Dependency còn có một số biểu hiện khác , thường dùng các stereotype sau :</p>

<ul>
<li><p><code>&lt;&lt;use&gt;&gt;</code> : chỉ rằng ngữ nghĩa của lớp gốc (mũi tên) phụ thuộc vào lớp ngọn (mũi tên) . Đặc biệt trong trường hợp lớp gốc dùng lớp ngọn làm tham số trong 1 số method của nó</p></li>
<li><p><code>&lt;&lt;permit&gt;&gt;</code> : chỉ rằng lớp gốc được quyền truy cập 1 cách đặc biệt vào lớp ngọn (chẳng hạn truy cập các thao tác riêng tư). Tương ứng với khái niệm friend trong C++</p></li>
<li><p><code>&lt;&lt;refine&gt;&gt;</code> : chỉ rằng lớp gốc ở 1 mức độ tinh chế cao hơn từ lớp ngọn . Chẳng hạn 1 lớp lập ở giai đoạn thiết kế nhằn tinh chế cùng lớp đó lập ở giai đoạn phân tích</p></li>
</ul>


<p>Lưu ý : Phân biệt giữa Dependency và Association</p>

<ul>
<li>Association là quan hệ cấu trúc</li>
<li>Dependency là qua hệ phi cấu trúc</li>
</ul>


<h3>Association</h3>

<p>Giữa 2 object của 2 lớp có sự ghép cặp (vợ – chồng , thầy – trò , khách hàng – hóa đơn …) . Tập hợp các kết nối cùng loại (cùng ý nghĩa) giữa các object của 2 lớp tạo thành mối liên kết association , quan hệ giữa 2 tập hợp (2 lớp)</p>

<p>Là mỗi liên hệ giữa 2 lớp có  role, role là tên vai trò của mối liên kết : vd như : của , cho , có , liên kết tới , trao đối với , …. (thường tên role có kèm theo 1 mũi tên để chỉ hướng quan hệ áp dụng từ lớp nào sang lớp nào)</p>

<p>Ký hiệu : A has-a B</p>

<p><img src="http://i.imgur.com/N6nkWbx.png"></p>

<p>Ý nghĩa : (trường hợp mũi tên không có chiều)
- Hoặc  : Trong ClassA có thuộc tính có kiểu là ClassB
- Hoặc  : Trong ClassB có thuộc tính có kiểu là ClassA</p>

<p>Nhận xét :</p>

<ul>
<li>Về mặt lập trình, thuộc tính có thể được lưu trữ dạng biến đơn, biến mảng, hay biến con trỏ</li>
<li>Có hoặc không có bản số cũng được</li>
<li>Có hoặc không có mũi tên cũng được</li>
<li>Nếu có mũi tên 1 chiều , chỉ ra chiều đối tượng thuộc lớp này chỉ có gọi đối tượng của lớp kia, không có chiều ngược lại</li>
<li>Nếu không có mũi tên nào thì tương đương là mũi tên 2 chiều , hoặc chiều không quan trọng.</li>
<li><code>Multiplicity</code> là bản số , lượng số , số object bên này tham gia vào mối kết hợp so với 1 object bên kia.</li>
</ul>


<h3>Quan hệ Aggregation (còn gọi là quan hệ thu nạp)</h3>

<p>Đã xác định được ClassA và ClassB có quan hệ Association với nhau</p>

<p>Xác định rõ hơn:</p>

<p>Trong object của ClassA có chứa (trong phần thuộc tính) object của ClassB</p>

<p>ObjectX của ClassA bị hủy thì ObjectY của ClassB (bên trong ObjectX) vẫn có thể còn tồn tại</p>

<p>Còn gọi là shared-aggregation.Một dạng của nối kết, trong đó một phần tử này chứa các phần tử khác.</p>

<p>Ký hiệu :</p>

<p><img src="http://i.imgur.com/nrYxfcB.png"></p>

<p>Ý nghĩa : còn gọi là : Whole A – Part B . Nghĩa là A được tạo từ nhiều B kết hợp lại , và B có thể tạo ra độc lập , không cần phải tạo ra A , B có thể cùng thuộc 1 whole khác A.</p>

<p>Chú ý : Từ share ở đây có nghĩa là , B có thể là bộ phận của whole khác, do đó A bị hủy thì chưa chắc B bị hủy .</p>

<h3>Quan hệ Composition (hợp thành)</h3>

<p>Là loại aggregation chặt chẽ hơn , còn gọi là non-shared aggregation.</p>

<p>Ký hiệu :</p>

<p><img src="http://i.imgur.com/HMYgISe.png"></p>

<p>Ý nghĩa : còn gọi là Whole A – Part B . Nghĩa là A được tạo từ nhiều B kết hợp lại , nhưng B không thể đứng 1 mình được , B chỉ là thuộc A mà thôi không thể cùng thuộc Whole khác được.</p>

<p>Đã xác định được ClassA và ClassB có quan hệ Association với nhau</p>

<p>Xác định rõ hơn:</p>

<ul>
<li>Trong object của ClassA có chứa (trong phần thuộc tính) object của ClassB</li>
<li>ObjectX của ClassA bị hủy thì ObjectY của ClassB (bên trong ObjectX) không thể còn tồn tại</li>
</ul>


<p>Chú ý :</p>

<ul>
<li>B chỉ có thể là bộ phận của whole A</li>
<li>A chết thì tất cả B chết</li>
<li>B chết không ảnh hưởng đến A</li>
<li>Bản số của Whole A luôn là 1, nghĩa là B luôn thuộc 1 A thôi</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/10/tao-blog-mien-phi-bang-octopress-and-github/">Tạo Blog Miễn Phí Bằng Octopress &amp; Github</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-10T10:38:33+09:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:38 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Octopress</h3>

<pre><code>$ git clone git://github.com/imathis/octopress.git octopress
$ cd octopress
$ bundle install --path vendor/bundle
</code></pre>

<h3>Thiết lập theme</h3>

<pre><code>$ git clone git://github.com/lucaslew/whitespace.git .themes/whitespace
$ rake install['whitespace'] # for zsh, use: rake install\['whitespace'\]
$ rake generate
</code></pre>

<h3>Thêm bài viết</h3>

<pre><code>$ rake new_post['Hello world']
</code></pre>

<h3>Xem trước</h3>

<pre><code>$ rake preview
</code></pre>

<h3>GitHub Pages</h3>

<pre><code>$ rake setup_github_pages
</code></pre>

<h3>Triển khai</h3>

<pre><code>$ rake generate
$ rake deploy
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/09/java-for-beginner/">Java for Beginner</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-09T19:40:19+09:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:40 pm</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Nguyên tắc trong java</h3>

<p>Dưới đây là năm mục tiêu chính khi làm việc với ngôn ngữ Java:</p>

<ul>
<li>Nó phải &ldquo;đơn giản, hướng đối tượng, và gần gũi&rdquo;.</li>
<li>Nó phải &ldquo;mạnh mẽ và bảo mật&rdquo;.</li>
<li>Nó phải &ldquo;Độc lập với cấu trúc và dễ di chuyển&rdquo;.</li>
<li>Nó phải &ldquo;hiệu suất cao&rdquo;.</li>
<li>Nó phải &ldquo;đa luồng, và có tính động&rdquo;</li>
</ul>


<h3>Lập trình hướng đối tượng</h3>

<p>Lập trình hướng đối tượng (gọi tắt là OOP, từ chữ Anh ngữ object-oriented programming), hay còn gọi là lập trình định hướng đối tượng, là kĩ thuật lập trình hỗ trợ công nghệ đối tượng. OOP được xem là giúp tăng năng suất, đơn giản hóa độ phức tạp khi bảo trì cũng như mở rộng phần mềm bằng cách cho phép lập trình viên tập trung vào các đối tượng phần mềm ở bậc cao hơn. Ngoài ra, nhiều người còn cho rằng OOP dễ tiếp thu hơn cho những người mới học về lập trình hơn là các phương pháp trước đó.</p>

<p>Một cách giản lược, đây là khái niệm và là một nỗ lực nhằm giảm nhẹ các thao tác viết mã cho người lập trình, cho phép họ tạo ra các ứng dụng mà các yếu tố bên ngoài có thể tương tác với các chương trình đó giống như là tương tác với các đối tượng vật lý.</p>

<p>Những đối tượng trong một ngôn ngữ OOP là các kết hợp giữa mã và dữ liệu mà chúng được nhìn nhận như là một đơn vị duy nhất. Mỗi đối tượng có một tên riêng biệt và tất cả các tham chiếu đến đối tượng đó được tiến hành qua tên của nó. Như vậy, mỗi đối tượng có khả năng nhận vào các thông báo, xử lý dữ liệu (bên trong của nó), và gửi ra hay trả lời đến các đối tượng khác hay đến môi trường.</p>

<h4>Tính trừu tượng (abstraction):</h4>

<p>Đây là khả năng của chương trình bỏ qua hay không chú ý đến một số khía cạnh của thông tin mà nó đang trực tiếp làm việc lên, nghĩa là nó có khả năng tập trung vào những cốt lõi cần thiết. Mỗi đối tượng phục vụ như là một &ldquo;động tử&rdquo; có thể hoàn tất các công việc một cách nội bộ, báo cáo, thay đổi trạng thái của nó và liên lạc với các đối tượng khác mà không cần cho biết làm cách nào đối tượng tiến hành được các thao tác. Tính chất này thường được gọi là sự trừu tượng của dữ liệu.</p>

<p>Tính trừu tượng còn thể hiện qua việc một đối tượng ban đầu có thể có một số đặc điểm chung cho nhiều đối tượng khác như là sự mở rộng của nó nhưng bản thân đối tượng ban đầu này có thể không có các biện pháp thi hành. Tính trừu tượng này thường được xác định trong khái niệm gọi là lớp trừu tượng hay lớp cơ sở trừu tượng.</p>

<h4>Tính đóng gói (encapsulation) và che giấu thông tin (information hiding):</h4>

<p>Tính chất này không cho phép người sử dụng các đối tượng thay đổi trạng thái nội tại của một đối tượng. Chỉ có các phương thức nội tại của đối tượng cho phép thay đổi trạng thái của nó. Việc cho phép môi trường bên ngoài tác động lên các dữ liệu nội tại của một đối tượng theo cách nào là hoàn toàn tùy thuộc vào người viết mã. Đây là tính chất đảm bảo sự toàn vẹn của đối tượng.</p>

<h4>Tính đa hình (polymorphism):</h4>

<p>Thể hiện thông qua việc gửi các thông điệp (message). Việc gửi các thông điệp này có thể so sánh như việc gọi các hàm bên trong của một đối tượng. Các phương thức dùng trả lời cho một thông điệp sẽ tùy theo đối tượng mà thông điệp đó được gửi tới sẽ có phản ứng khác nhau. Người lập trình có thể định nghĩa một đặc tính (chẳng hạn thông qua tên của các phương thức) cho một loạt các đối tượng gần nhau nhưng khi thi hành thì dùng cùng một tên gọi mà sự thi hành của mỗi đối tượng sẽ tự động xảy ra tương ứng theo đặc tính của từng đối tượng mà không bị nhầm lẫn.</p>

<p>Thí dụ khi định nghĩa hai đối tượng &ldquo;hinh_vuong&rdquo; và &ldquo;hinh_tron&rdquo; thì có một phương thức chung là &ldquo;chu_vi&rdquo;. Khi gọi phương thức này thì nếu đối tượng là &ldquo;hinh_vuong&rdquo; nó sẽ tính theo công thức khác với khi đối tượng là &ldquo;hinh_tron&rdquo;.</p>

<h4>Tính kế thừa (inheritance):</h4>

<p>Đặc tính này cho phép một đối tượng có thể có sẵn các đặc tính mà đối tượng khác đã có thông qua kế thừa. Điều này cho phép các đối tượng chia sẻ hay mở rộng các đặc tính sẵn có mà không phải tiến hành định nghĩa lại. Tuy nhiên, không phải ngôn ngữ định hướng đối tượng nào cũng có tính chất này.</p>

<h3>Một số khái niệm cần biết</h3>

<h4>Lớp (class)</h4>

<p>Một lớp có thể được hiểu là khuôn mẫu để tạo ra các đối tượng. Trong một lớp, người ta thường dùng các biến để mô tả các thuộc tính và các hàm để mô tả các phương thức của đối tượng. Khi đã định nghĩa được lớp, ta có thể tạo ra các đối tượng từ lớp này. Để việc sử dụng được dễ dàng, thông qua hệ thống hàm tạo (constructor), người ta dùng lớp như một kiểu dữ liệu để tạo ra các đối tượng.</p>

<h4>Lớp con (subclass)</h4>

<p>Lớp con là một lớp thông thường nhưng có thêm tính chất kế thừa một phần hay toàn bộ các đặc tính của một lớp khác. Lớp chia sẻ sự kế thừa gọi là lớp cha (parent class).</p>

<h4>Lớp trừu tượng hay lớp cơ sở trừu tượng (abstract class)</h4>

<p>Lớp trừu tượng là một lớp mà nó không thể thực thể hóa thành một đối tượng thực dụng được. Lớp này được thiết kế nhằm tạo ra một lớp có các đặc tính tổng quát nhưng bản thân lớp đó chưa có ý nghĩa (hay không đủ ý nghĩa) để có thể tiến hành viết mã cho việc thực thể hóa. (xem thí dụ)</p>

<p>Thí dụ: Lớp &ldquo;hinh&rdquo; được định nghĩa không có dữ liệu nội tại và chỉ có các phương thức (hàm nội tại) &ldquo;tinh_chu_vi&rdquo;, &ldquo;tinh_dien_tich&rdquo;. Nhưng vì lớp hinh này chưa xác định được đầy đủ các đặc tính của nó (cụ thể các biến nội tại là tọa độ các đỉnh nếu là đa giác, là đường bán kính và toạ độ tâm nếu là hình tròn,&hellip;) nên nó chỉ có thể được viết thành một lớp trừu tượng. Sau đó, người lập trình có thể tạo ra các lớp con chẳng hạn như là lớp &ldquo;tam_giac&rdquo;, lớp &ldquo;hinh_tron&rdquo;, lớp &ldquo;tu_giac&rdquo;,&hellip;. Và trong các lớp con này người viết mã sẽ cung cấp các dữ liệu nội tại (như là biến nội tại r làm bán kính và hằng số nội tại Pi cho lớp &ldquo;hinh_tron&rdquo; và sau đó viết mã cụ thể cho các phương thức &ldquo;tinh_chu_vi&rdquo; và &ldquo;tinh_dien_tich&rdquo;).</p>

<h4>Phương thức (method)</h4>

<p>Phương thức của một lớp thường được dùng để mô tả các hành vi của đối tượng (hoặc của lớp). Ví dụ như đối tượng thuộc lớp điện thoại có các hành vi sau: Đổ chuông, chuyển tín hiệu từ sóng sang dạng nghe được, chuyển tín hiệu giọng nói sang dạng chuẩn, chuyển tín hiệu lên tổng đài.v.v. Khi thiết kế, người ta có thể dùng các phương thức để mô tả và thực hiện các hành vi của đối tượng. Mỗi phương thức thường được định nghĩa là một hàm, các thao tác để thực hiện hành vi đó được viết tại nội dung của hàm. Khi thực hiện hành vi này, đối tượng có thể phải thực hiện các hành vi khác. Ví dụ như điện thoại phải chuyển tín hiệu giọng nói sang dạng chuẩn trước khi chuyển lên tổng đài. Cho nên một phương thức trong một lớp có thể sử dụng phương thức khác trong quá trình thực hiện hành vi của mình.</p>

<p>Người ta còn định nghĩa thêm vài loại phương thức đặc biệt:</p>

<ul>
<li>Hàm tạo (constructor) là hàm được dùng để tạo ra một đối tượng, cài đặt các giá trị ban đầu cho các thuộc tính của đối tượng đó.</li>
<li>Hàm hủy (destructor) là hàm dùng vào việc làm sạch bộ nhớ đã dùng để lưu đối tượng và hủy bỏ tên của một đối tượng sau khi đã dùng xong, trong đó có thể bao gồm cả việc xóa các con trỏ nội tại và trả về các phần bộ nhớ mà đối tượng đã dùng.</li>
</ul>


<p>Nhiều lớp thư viện có sẵn hàm tạo mặc định (thông thường không có tham số) và hàm huỷ.</p>

<h4>Thuộc tính (attribute)</h4>

<p>Thuộc tính của một lớp bao gồm các biến, các hằng, hay tham số nội tại của lớp đó. Ở đây, vai trò quan trọng nhất của các thuộc tính là các biến vì chúng sẽ có thể bị thay đổi trong suốt quá trình hoạt động của một đối tượng. Các thuộc tính có thể được xác định kiểu và kiểu của chúng có thể là các kiểu dữ liệu cổ điển hay đó là một lớp đã định nghĩa từ trước. Như đã ghi, khi một lớp đã được thực thể hoá thành đối tượng cụ thể thì tập hợp các giá trị của các biến nội tại làm thành trạng thái của đối tượng. Giống như trường hợp của phương thức, tùy theo người viết mã, biến nội tại có thể chỉ được dùng bên trong các phương thức của chính lớp đó, có thể cho phép các câu lệnh bên ngoài lớp, hay chỉ cho phép các lớp có quan hệ đặc biệt như là quan hệ lớp con, (và quan hệ bạn bè (friend) trong C++) được phép dùng tới nó (hay thay đổi giá trị của nó). Mỗi thuộc tính của một lớp còn được gọi là thành viên dữ liệu của lớp đó.</p>

<h4>Thực thể hóa (instantiate)</h4>

<p>Là quá trình khai báo để có một tên (có thể được xem như là một biến) trở thành một đối tượng từ một lớp nào đó.</p>

<p>Một lớp sau khi được tiến hành thực thể hóa để có một đối tượng cụ thể gọi là một thực thể. Hay nói ngược lại một thực thể là một đối tượng riêng lẻ của một lớp đã định trước. Như các biến thông thường, hai thực thể của cùng một lớp có thể có trạng thái nội tại khác nhau (xác định bởi các giá trị hiện có của các biến nội tại) và do đó hoàn toàn độc lập nhau nếu không có yêu cầu gì đặc biệt từ người lập trình. &ldquo; Thực thể hóa: gần giống như cá nhân hóa. Một lớp khi được &rdquo; cá nhân hóa" sẽ thành một đối tượng cụ thể.</p>

<h4>Công cộng (public)</h4>

<p>Công cộng là một tính chất được dùng để gán cho các phương thức, các biến nội tại, hay các lớp mà khi khai báo thì người lập trình đã cho phép các câu lệnh bên ngoài cũng như các đối tượng khác được phép dùng đến nó.</p>

<h4>Riêng tư (private)</h4>

<p>Riêng tư là sự thể hiện tính chất đóng mạnh nhất (của một đặc tính hay một lớp). Khi dùng tính chất này gán cho một biến, một phương thức thì biến hay phương thức đó chỉ có thể được sử dụng bên trong của lớp mà chúng được định nghĩa. Mọi nỗ lực dùng trực tiếp đến chúng từ bên ngoài qua các câu lệnh hay từ các lớp con sẽ bị phủ nhận hay bị lỗi.</p>

<h4>Bảo tồn (protected)</h4>

<p>Tùy theo ngôn ngữ, sẽ có vài điểm nhỏ khác nhau về cách hiểu tính chất này. Nhìn chung đây là tính chất mà khi dùng để áp dụng cho các phương thức, các biến nội tại, hay các lớp thì chỉ có trong nội bộ của lớp đó hay các lớp con của nó (hay trong nội bộ một gói như trong Java) được phép gọi đến hay dùng đến các phương pháp, biến hay lớp đó.</p>

<p>So với tính chất riêng tư thì tính bảo tồn rộng rãi hơn về nghĩa chia sẻ dữ liệu hay chức năng. Nó cho phép một số trường hợp được dùng tới các đặc tính của một lớp (từ một lớp con chẳng hạn).</p>

<p>Lưu ý: Các tính chất công cộng, riêng tư và bảo tồn đôi khi còn được dùng để chỉ thị cho một lớp con cách thức kế thừa một lớp cha như trong C++.</p>

<h4>Đa kế thừa (multiple inheritance)</h4>

<p>Đây là một tính chất cho phép một lớp con có khả năng kế thừa trực tiếp cùng lúc nhiều lớp khác.</p>

<p>Vài điểm cần lưu ý khi viết mã dùng tính chất đa kế thừa:</p>

<ul>
<li>Khi muốn có một sự kế thừa từ nhiều lớp cha thì các lớp này cần phải độc lập và đặc biệt tên của các dữ liệu hay hàm cho phép kế thừa phải có tên khác nhau để tránh lỗi &ldquo;ambiguity&rdquo;. Bởi vì lúc đó trình dịch sẽ không thể xác định được là lớp con sẽ thừa kế tên nào của các lớp cha.</li>
<li>Nhiều ngôn ngữ, ví dụ như Java, không có đa thừa kế, nhưng chúng có khái niệm giao diện Interface. Với Interface, ta có thể có hầu hết các lợi ích mà đa thừa kế mang lại.</li>
</ul>


<p>Ngoài các khái niệm trên, tùy theo ngôn ngữ, có thể sẽ có các chức năng OOP riêng biệt được cấp thêm vào.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/09/introduction-to-restful-webservice/">Explore About RESTful Webservice</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-09T10:39:53+09:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:39 am</span></time>
        
        
      </p>
    
  </header>


  <div class="entry-content"><h3>RESTtful webservice là gì?</h3>

<p>REST là một tập hợp các nguyên tắc mà dữ liệu có thể truyền qua phương thức truyền tin (như là HTTP). REST  là từ viết tắt của Representational State Transfer.</p>

<p>This basically means that each unique URL is a representation of some object.</p>

<p>Represntational : Tiêu biểu, tượng trưng; Đại diện, thay mặt</p>

<p>State: Trạng thái; tình trạng</p>

<p>Transfer: Sự di chuyển, sự dời chỗ; sự truyền</p>

<p>REST yêu cầu người lập trình sử dụng các phương thức HTTP một cách rõ ràng và theo một cách phù hợp với định nghĩa giao thức. Nguyên tắc thiết kế cơ bản là thiết lập một ánh xạ 1:1 giữa create, read, update và delete (CRUD) và HTTP methods. Tuân theo quy tắc dưới đây:</p>

<ul>
<li>Để &ldquo;create&rdquo;, hãy sử dụng POST</li>
<li>Để &ldquo;read&rdquo;, hãy sử dụng GET.</li>
<li>Để &ldquo;update&rdquo;, hãy sử dụng PUT.</li>
<li>Để &ldquo;delete&rdquo;, hãy sử dụng DELETE.</li>
</ul>


<h3>Who is using Restful webservice?</h3>

<p>Internet giants like Yahoo, Amazon, eBay and more are using Restful webservice</p>

<h3>Rest vs SOAP</h3>

<table>
<thead>
<tr>
<th> REST                                                  </th>
<th> SOAP                                          </th>
</tr>
</thead>
<tbody>
<tr>
<td> REST stands for REpresentational State Transfer       </td>
<td> SOAP stands for Simple Object Access Protocol </td>
</tr>
<tr>
<td> REST is not XML protocol based                        </td>
<td> SOAP is a XML based messaging protocol        </td>
</tr>
<tr>
<td> REST doesn’t have any specification                     </td>
<td> SOAP has specifications like WSDL etc         </td>
</tr>
<tr>
<td> REST doesn’t enforce message format as XML or JSON  </td>
<td> SOAP enforces message format as XML           </td>
</tr>
<tr>
<td> Light weight – due to the usage of JSON             </td>
<td> Heavy weight – due to the usage of XML      </td>
</tr>
<tr>
<td> Easy to parse the response                            </td>
<td> Bit difficult to parse the response           </td>
</tr>
</tbody>
</table>


<h3>RESTFul Webservice Request and Response – Drill down</h3>

<p>Bước đầu tiên khi thiết kế RESTFul webservice là lựa chọn domain name đúng - gửi đến weatherinfo.org để hỏi thông tin thời tiết của các thành phố.</p>

<p>Hãy xem ví dụ đầu tiên (weatherinfo.org) đã lấy tên thành phố là đầu vào, lấy thông tin thời tiết của thành phố và gửi trả kết quả lại cho trình duyệt. Giả sử các kết quả trả về là XML format, nó có thể là JSON một cách dễ dàng.</p>

<p>Dưới đây là cấu trúc của Request và Response:</p>

<h4>HTTP Request</h4>

<p>The client request from the browser will look like:</p>

<pre><code>GET http://weatherinfo.org/getweather/mumbai HTTP/1.1
</code></pre>

<h4>HTTP Response</h4>

<p>The server response will look like</p>

<pre><code>HTTP/1.1 200 Ok
Date: Mon, 14 Apr 2014 10:20:58 GMT
Content-Type: text/xml
Content-length: 139

&lt;City name="Mumbai" datetime="2014-04-14 10:20:58 GMT" &gt;
&lt;Condition&gt;Scattered Clouds&lt;/Condition&gt;
&lt;Temp&gt;33&lt;/Temp&gt;
&lt;/City&gt;
</code></pre>

<p>Line 1 is the initial line which has the HTTP response code – 200 OK, lines 2 through 4 are the HTTP headers (there can be lots of headers, only 3 are shown here), line 5 is the mandatory blank line separating header and body, and lines 6 through 10 constitute the “HTTP Body (or content)” – this part is the data that the response carries and can be in any format, not necessarily XML.</p>

<p>In fact, the most commonly used format on the web is HTML – one that web servers use to send back data to browsers. Whatever it is, the “Content-type” header usually specifies it. But if you are writing a web service, JSON is a better choice, but that is upto me. If your web service does not return complex or composite data, the format does not need to be JSON – it can be plain , in which case the body will just be a string of characters.</p>

<h3>Advantages of using RESTful webservice</h3>

<ol>
<li><p>RESTful Web services are designed with less dependence on proprietary middleware (for example, an application server) than the SOAP- and WSDL-based kind.</p></li>
<li><p>As per the RESTful interface design, XML or JSON over HTTP is a powerful interface that allows internal applications, such as Asynchronous JavaScript + XML/JSON (Ajax)-based custom user interfaces, to easily connect, address, and consume resources.</p></li>
<li><p>The great fit between Ajax and REST has increased the amount of attention REST is getting these days.</p></li>
<li><p>Exposing a system’s resources through a RESTful API is a flexible way to provide different kinds of applications with data formatted in a standard way. It helps to meet integration requirements that are critical to building systems where data can be easily combined (mashups) and to extend or build on a set of base, RESTful services into something much bigger.</p></li>
</ol>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - ダン・クァン・ミン -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
